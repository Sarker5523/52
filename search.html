<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Search - StreamOn</title>
    <meta http-equiv="Content-Security-Policy" content="frame-src 'self' https://www.youtube.com https://mp.rpmhub.site https://cybervynx.com; connect-src 'self' https://api.themoviedb.org;">
    <link rel="stylesheet" href="styles.css" />
    <style>
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 20px;
            font-size: 16px;
        }
        .pagination button, .pagination span {
            padding: 8px 12px;
            border: 1px solid #00ab41;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(to bottom, rgba(43, 43, 43, 0.8), rgba(0, 0, 0, 0.5));
            color: #ffffff;
            transition: background 0.3s ease, border-color 0.3s ease;
        }
        .pagination button:hover, .pagination span:hover {
            border-color: #00ff9c;
            background: linear-gradient(to right, #1a1a1a, #333);
        }
        .pagination .active {
            background: #00ab41;
            border-color: #00ab41;
            color: #fff;
        }
        .pagination .disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="navbar">
        <div class="logo" onclick="window.location.href = 'index.html'">StreamOn</div>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <div class="dropdown">
                Categories
                <div class="dropdown-content" id="category-list"></div>
            </div>
            <div class="search-container">
                <input id="search-box" class="search-box" type="text" placeholder="Search..." autocomplete="off" />
                <div id="instant-results" class="search"></div>
            </div>
        </div>
    </div>

    <main id="main" class="content-wrap">
        <section class="category-section" style="padding:20px;">
            <h2 id="search-title">Search Results</h2>
            <div id="results" class="video-grid"></div>
            <div id="pagination" class="pagination"></div>
            <div id="no-results" style="display:none; text-align:center; padding:30px;">No results found.</div>
        </section>
    </main>

    <script>
        (function () {
            const TMDB_API_KEY = 'ef93f865877bb70f8175a613d28b8ebe';
            const searchBox = document.getElementById('search-box');
            const instantResults = document.getElementById('instant-results');
            const resultsEl = document.getElementById('results');
            const noResultsEl = document.getElementById('no-results');
            const paginationEl = document.getElementById('pagination');
            const categoryList = document.getElementById('category-list');
            const ITEMS_PER_PAGE = 12;
            let currentPage = 1;
            let allResults = [];
            let genreMap = null;

            const normalize = s => (s || '').toString().toLowerCase().trim();

            // Load local cached extended metadata
            let movieDataCache = {};
            try { movieDataCache = JSON.parse(localStorage.getItem('movieDataCache')) || {}; } catch(e) { movieDataCache = {}; }

            // Fetch TMDb genre list
            async function fetchGenreMap() {
                if (genreMap) return genreMap;
                try {
                    const response = await fetch(
                        `https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}&language=en-US`
                    );
                    if (!response.ok) throw new Error(`TMDb genre list API error: ${response.status}`);
                    const data = await response.json();
                    genreMap = {};
                    data.genres.forEach(genre => {
                        genreMap[genre.id] = genre.name;
                    });
                    return genreMap;
                } catch (error) {
                    console.error('Error fetching TMDb genre list:', error);
                    return {};
                }
            }

            // Fetch TMDb data
            async function fetchMovieData(imdbID) {
                const cacheKey = imdbID; // Use imdbID as cache key since name is not in JSON
                if (movieDataCache[cacheKey] && movieDataCache[cacheKey].genres) {
                    return movieDataCache[cacheKey];
                }
                await new Promise(resolve => setTimeout(resolve, 100)); // Rate limit delay
                const maxRetries = 3;
                let attempt = 0;

                while (attempt < maxRetries) {
                    try {
                        const tmdbResponse = await fetch(
                            `https://api.themoviedb.org/3/find/${imdbID}?api_key=${TMDB_API_KEY}&language=en-US&external_source=imdb_id`
                        );
                        if (tmdbResponse.status === 429) {
                            attempt++;
                            const delay = Math.pow(2, attempt) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        if (!tmdbResponse.ok) throw new Error(`TMDb API error: ${tmdbResponse.status}`);
                        const tmdbData = await tmdbResponse.json();
                        if (tmdbData.movie_results?.length > 0) {
                            const tmdbMovieId = tmdbData.movie_results[0].id;
                            const movieResponse = await fetch(
                                `https://api.themoviedb.org/3/movie/${tmdbMovieId}?api_key=${TMDB_API_KEY}&language=en-US`
                            );
                            if (!movieResponse.ok) throw new Error(`TMDb movie details API error: ${movieResponse.status}`);
                            const movieData = await movieResponse.json();
                            
                            const itemData = {
                                name: movieData.title || 'Unknown Title',
                                thumbnail: movieData.poster_path ? `https://image.tmdb.org/t/p/w500${movieData.poster_path}` : 'path/to/placeholder.jpg',
                                genres: movieData.genres?.length > 0
                                    ? movieData.genres.map(g => g.name)
                                    : movieData.genre_ids?.length > 0
                                        ? (await fetchGenreMap())[movieData.genre_ids[0]]
                                            ? movieData.genre_ids.map(id => genreMap[id]).filter(Boolean)
                                            : ['Uncategorized']
                                        : ['Uncategorized'],
                                rating: movieData.vote_average ? movieData.vote_average.toFixed(1) : 'N/A',
                                type: 'movie',
                                imdbID: imdbID
                            };
                            movieDataCache[cacheKey] = itemData;
                            try {
                                localStorage.setItem('movieDataCache', JSON.stringify(movieDataCache));
                            } catch (e) {
                                if (e.name === 'QuotaExceededError') {
                                    console.warn('localStorage full, clearing cache');
                                    localStorage.removeItem('movieDataCache');
                                    movieDataCache = {};
                                }
                            }
                            return itemData;
                        }
                        return null;
                    } catch (error) {
                        console.error(`Error fetching TMDb data for ${imdbID} (attempt ${attempt + 1}):`, error);
                        attempt++;
                        if (attempt === maxRetries) break;
                    }
                }
                // Fallback if TMDb fails
                return {
                    name: 'Unknown Title',
                    thumbnail: 'path/to/placeholder.jpg',
                    genres: ['Uncategorized'],
                    rating: 'N/A',
                    type: 'movie',
                    imdbID: imdbID
                };
            }

            async function loadJsons() {
                const fetchSafe = url => fetch(url).then(r => r.ok ? r.json() : []).catch(() => []);
                const [movies, series] = await Promise.all([fetchSafe('movies.json'), fetchSafe('series.json')]);
                const data = [
                    ...movies.map(i => ({ imdbID: i.imdbID, type: 'movie' })),
                    ...series.map(i => ({ imdbID: i.imdbID, type: 'series' }))
                ];
                
                const enrichedData = [];
                for (const item of data) {
                    const tmdbItem = await fetchMovieData(item.imdbID);
                    if (tmdbItem) {
                        enrichedData.push({
                            ...item,
                            name: tmdbItem.name,
                            thumbnail: tmdbItem.thumbnail,
                            genres: tmdbItem.genres,
                            rating: tmdbItem.rating,
                            type: item.type
                        });
                    } else {
                        enrichedData.push({
                            ...item,
                            name: 'Unknown Title',
                            thumbnail: 'path/to/placeholder.jpg',
                            genres: ['Uncategorized'],
                            rating: 'N/A'
                        });
                    }
                    // Special case for Dhadak 2
                    if (item.imdbID === 'tt13451410') {
                        enrichedData[enrichedData.length - 1] = {
                            ...enrichedData[enrichedData.length - 1],
                            name: 'Dhadak 2',
                            thumbnail: enrichedData[enrichedData.length - 1].thumbnail || 'path/to/placeholder.jpg',
                            genres: enrichedData[enrichedData.length - 1].genres[0] !== 'Uncategorized' ? enrichedData[enrichedData.length - 1].genres : ['Bollywood Movie'],
                            rating: enrichedData[enrichedData.length - 1].rating || '6.8',
                            type: 'movie'
                        };
                    }
                }
                return enrichedData;
            }

            function renderItem(item, meta) {
                const thumbnail = item.thumbnail && item.thumbnail !== 'N/A' ? item.thumbnail : 'path/to/placeholder.jpg';
                const rating = (meta && meta.rating) || item.rating || 'N/A';
                const nameHash = (item.name || '').replace(/\s+/g, '');
                const page = item.type === 'series' ? 'series.html' : 'movie.html';
                const a = document.createElement('a');
                a.href = `${page}#${nameHash}`;
                a.className = 'video-item';
                a.innerHTML = `
                    <img src="${thumbnail}" alt="${item.name || 'Untitled'}">
                    <span>${item.name || 'Untitled'}</span>
                    <div class="imdb-rating" data-rating="${rating}">IMDB: ${rating}</div>
                `;
                return a;
            }

            function renderPagination(totalItems) {
                paginationEl.innerHTML = '';
                const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
                if (totalPages <= 1) return;

                const prevBtn = document.createElement('button');
                prevBtn.textContent = 'Previous';
                prevBtn.className = currentPage === 1 ? 'disabled' : '';
                prevBtn.disabled = currentPage === 1;
                prevBtn.onclick = () => {
                    if (currentPage > 1) {
                        currentPage--;
                        renderResults(allResults);
                    }
                };
                paginationEl.appendChild(prevBtn);

                const maxVisiblePages = 5;
                let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                if (endPage - startPage + 1 < maxVisiblePages) {
                    startPage = Math.max(1, endPage - maxVisiblePages + 1);
                }

                for (let i = startPage; i <= endPage; i++) {
                    const pageBtn = document.createElement('span');
                    pageBtn.textContent = i;
                    pageBtn.className = i === currentPage ? 'active' : '';
                    pageBtn.onclick = () => {
                        currentPage = i;
                        renderResults(allResults);
                    };
                    paginationEl.appendChild(pageBtn);
                }

                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Next';
                nextBtn.className = currentPage === totalPages ? 'disabled' : '';
                nextBtn.disabled = currentPage === totalPages;
                nextBtn.onclick = () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        renderResults(allResults);
                    }
                };
                paginationEl.appendChild(nextBtn);
            }

            function renderResults(items) {
                allResults = items;
                resultsEl.innerHTML = '';
                if (!items.length) {
                    noResultsEl.style.display = 'block';
                    paginationEl.style.display = 'none';
                    return;
                }
                noResultsEl.style.display = 'none';
                paginationEl.style.display = 'flex';

                const start = (currentPage - 1) * ITEMS_PER_PAGE;
                const end = start + ITEMS_PER_PAGE;
                const paginatedItems = items.slice(start, end);

                paginatedItems.forEach(item => {
                    const meta = movieDataCache[item.imdbID] || {};
                    resultsEl.appendChild(renderItem(item, meta));
                });

                renderPagination(items.length);
            }

            function showInstant(results) {
                instantResults.innerHTML = '';
                if (!results.length) { instantResults.style.display = 'none'; return; }
                results.slice(0, 6).forEach(item => {
                    const meta = movieDataCache[item.imdbID] || {};
                    const thumbnail = item.thumbnail || meta.thumbnail || 'path/to/placeholder.jpg';
                    const rating = meta.rating || item.rating || 'N/A';
                    const nameHash = (item.name || '').replace(/\s+/g, '');
                    const page = item.type === 'series' ? 'series.html' : 'movie.html';
                    const div = document.createElement('div');
                    div.className = 'search-suggestion';
                    div.innerHTML = `
                        <img src="${thumbnail}" alt="${item.name || 'Untitled'}">
                        <span>${item.name || 'Untitled'}</span>
                        <div class="imdb-rating" data-rating="${rating}">IMDB: ${rating}</div>
                    `;
                    div.onclick = () => window.location.href = `${page}#${nameHash}`;
                    instantResults.appendChild(div);
                });
                instantResults.style.display = 'block';
            }

            async function populateCategories(items) {
                const cats = [...new Set(items.flatMap(i => i.genres || ['Uncategorized']).filter(Boolean))];
                categoryList.innerHTML = '';
                cats.forEach(cat => {
                    const a = document.createElement('a');
                    a.href = `category.html#${cat.replace(/\s+/g, '')}`;
                    a.textContent = cat;
                    categoryList.appendChild(a);
                });
            }

            function applyFilters(items, filter) {
                if (!filter) return items;
                const f = filter;
                return items.filter(item => {
                    const meta = movieDataCache[item.imdbID] || {};
                    if (f.type === 'keyword') {
                        return normalize(item.name).includes(normalize(f.value));
                    }
                    if (f.type === 'name') {
                        return normalize(item.name.replace(/\s+/g, '')) === normalize(f.value.replace(/\s+/g, ''));
                    }
                    if (f.type === 'genre') {
                        const genres = (meta.genres || item.genres || ['Uncategorized']).map(normalize);
                        return genres.includes(normalize(f.value));
                    }
                    if (f.type === 'director') {
                        return normalize(meta.director || item.director || '').includes(normalize(f.value));
                    }
                    if (f.type === 'actor') {
                        const actors = (meta.actors || item.actors || []).join(',');
                        return normalize(actors).includes(normalize(f.value));
                    }
                    if (f.type === 'year') {
                        return normalize((meta.release_year || item.release_year || '')).includes(normalize(f.value));
                    }
                    return false;
                });
            }

            function parseHash() {
                const raw = (window.location.hash || '').substring(1);
                if (!raw) return null;
                const kv = raw.split('&').map(x => x.trim());
                for (const part of kv) {
                    const [k, ...rest] = part.split('=');
                    const value = rest.join('=');
                    if (!value) {
                        return {type: 'name', value: part};
                    }
                    const key = k.toLowerCase();
                    if (['keyword','q','query'].includes(key)) return {type:'keyword', value: decodeURIComponent(value)};
                    if (key === 'director') return {type:'director', value: decodeURIComponent(value)};
                    if (key === 'actor') return {type:'actor', value: decodeURIComponent(value)};
                    if (key === 'genre') return {type:'genre', value: decodeURIComponent(value)};
                    if (key === 'year') return {type:'year', value: decodeURIComponent(value)};
                }
                return {type:'keyword', value: decodeURIComponent(raw)};
            }

            searchBox.addEventListener('input', function () {
                const q = this.value.trim();
                if (!q) { instantResults.style.display = 'none'; return; }
                loadJsons().then(all => {
                    const matches = all.filter(i => normalize(i.name).includes(normalize(q)));
                    showInstant(matches);
                });
            });

            searchBox.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    const q = this.value.trim();
                    if (!q) return;
                    document.getElementById('search-title').textContent = `Results for "${q}"`;
                    loadJsons().then(all => {
                        const filtered = all.filter(i => normalize(i.name).includes(normalize(q)));
                        currentPage = 1;
                        renderResults(filtered);
                        instantResults.style.display = 'none';
                    });
                }
            });

            (async function init() {
                const all = await loadJsons();
                await populateCategories(all);

                const filter = parseHash();
                if (filter) {
                    const titleMap = {
                        keyword: `Results for "${filter.value}"`,
                        name: `Results for "${filter.value}"`,
                        director: `Director: ${filter.value}`,
                        actor: `Actor: ${filter.value}`,
                        genre: `Genre: ${filter.value}`,
                        year: `Year: ${filter.value}`
                    };
                    document.getElementById('search-title').textContent = titleMap[filter.type] || 'Search Results';
                    const filtered = applyFilters(all, filter);
                    currentPage = 1;
                    renderResults(filtered);
                } else {
                    document.getElementById('search-title').textContent = 'Search movies & series';
                    renderResults([]);
                }
            })();

            document.addEventListener('click', (ev) => {
                if (!ev.target.closest('.search-container')) instantResults.style.display = 'none';
            });
        })();
    </script>
</body>
</html>
