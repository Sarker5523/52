<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Details</title>
  <!-- Adjusted CSP to allow WebSocket for development -->
  <meta http-equiv="Content-Security-Policy" content="frame-src 'self' https://www.youtube.com https://mp.rpmhub.site https://cybervynx.com; connect-src 'self' https://api.themoviedb.org ws://127.0.0.1:3001;">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Inter:wght@500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* For lists */
    #main-cast, #imdb-categories {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .error-message {
      color: red;
      text-align: center;
      padding: 20px;
      display: none;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <div class="navbar">
    <div class="logo" onclick="window.location.href = 'index.html'" role="button" aria-label="StreamOn Home">StreamOn</div>
    <div class="nav-links">
      <a href="index.html" aria-label="Home">Home</a>
      <div class="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
        Categories
        <div class="dropdown-content" id="category-list"></div>
      </div>
      <div class="search-container">
        <input
          type="text"
          id="search-box"
          class="search-box"
          placeholder="Search..."
          autocomplete="off"
          aria-label="Search movies"
        />
        <div id="search" class="search" role="listbox"></div>
      </div>
    </div>
  </div>

  <div class="video-container" id="video-container">
    <div class="iframe-container" id="iframe-container" style="display: none;" role="region" aria-label="Video player"></div>
  </div>

  <div class="video-details">
    <h2 id="video-title" aria-live="polite"></h2>
    <div id="error-message" class="error-message"></div>
    <div id="source-selection" class="episode-list"></div>
    <div class="movie-info" id="movie-info" style="display: none;">
      <div class="plot-container">
        <div class="plot-text">
          <h3>Plot</h3>
          <p id="movie-plot"></p>
        </div>
      </div>
      <div class="info-columns">
        <div class="left-column">
          <h3>Director</h3>
          <div id="director" class="director"></div>
          <h3>Main Cast</h3>
          <div id="main-cast" class="cast-list"></div>
          <h3>Genres</h3>
          <div id="imdb-categories" class="imdb-categories"></div>
          <h3>Released Year</h3>
          <div id="release-year" class="release-year"></div>
        </div>
        <div class="right-column">
          <div class="imdb-rating-circle" id="imdb-rating-circle" style="display: none;">
            <div class="rating-circle" id="rating-circle">
              <span id="rating-value">0</span>
            </div>
            <span class="rating-text">IMDB Rating</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Trailer Section -->
  <div class="trailer-container" id="trailer-container" style="display: none;">
    <h3 class="trailer-title">Trailer</h3>
    <div class="iframe-container" id="trailer-iframe-container" role="region" aria-label="Movie trailer"></div>
  </div>

  <script>
    const searchInput = document.getElementById("search-box");
    const searchResultsContainer = document.getElementById("search");
    const iframeContainer = document.getElementById("iframe-container");
    const trailerContainer = document.getElementById("trailer-container");
    const trailerIframeContainer = document.getElementById("trailer-iframe-container");
    const trailerTitle = document.querySelector(".trailer-title");
    const categoryList = document.getElementById("category-list");
    const sourceSelection = document.getElementById("source-selection");
    const imdbRatingCircle = document.getElementById("imdb-rating-circle");
    const ratingCircle = document.getElementById("rating-circle");
    const ratingValue = document.getElementById("rating-value");
    const movieInfo = document.getElementById("movie-info");
    const moviePlot = document.getElementById("movie-plot");
    const director = document.getElementById("director");
    const mainCast = document.getElementById("main-cast");
    const imdbCategories = document.getElementById("imdb-categories");
    const releaseYear = document.getElementById("release-year");
    const errorMessage = document.getElementById("error-message");

    const TMDB_API_KEY = 'ef93f865877bb70f8175a613d28b8ebe';
    let genreMap = null;

    const normalize = (str) => str ? str.toLowerCase().trim().replace(/[^\w\s]/g, '') : '';

    // IndexedDB Setup
    const DB_NAME = 'StreamOnDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'movieCache';
    let db;

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = function (event) {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'imdbID' });
          }
        };

        request.onsuccess = function (event) {
          db = event.target.result;
          resolve(db);
        };

        request.onerror = function (event) {
          console.error('IndexedDB error:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Load cache from IndexedDB and LocalStorage
    async function loadCache() {
      let dataCache = {};
      try {
        // Check LocalStorage for metadata
        const cacheMetadata = localStorage.getItem('movieCacheMetadata');
        let metadata = cacheMetadata ? JSON.parse(cacheMetadata) : { lastUpdated: 0, keys: [] };

        // Open IndexedDB
        await openDB();

        // Get data from IndexedDB
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        return new Promise((resolve) => {
          request.onsuccess = function (event) {
            dataCache = Object.fromEntries(event.target.result.map(item => [item.imdbID, item]));
            // Fallback to LocalStorage if IndexedDB is empty
            if (Object.keys(dataCache).length === 0) {
              try {
                const localCache = localStorage.getItem('movieDataCache');
                if (localCache) {
                  dataCache = JSON.parse(localCache);
                }
              } catch (e) {
                console.warn('Error loading LocalStorage cache:', e);
              }
            }
            resolve({ dataCache, metadata });
          };

          request.onerror = function () {
            console.warn('Error reading from IndexedDB, falling back to LocalStorage');
            try {
              const localCache = localStorage.getItem('movieDataCache');
              if (localCache) {
                dataCache = JSON.parse(localCache);
              }
            } catch (e) {
              console.warn('Error loading LocalStorage cache:', e);
            }
            resolve({ dataCache, metadata });
          };
        });
      } catch (e) {
        console.warn('Error loading cache:', e);
        return { dataCache, metadata: { lastUpdated: 0, keys: [] } };
      }
    }

    // Save cache to IndexedDB and update LocalStorage metadata
    async function saveCache(dataCache, metadata) {
      try {
        // Update IndexedDB
        await openDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        // Enforce size limit (e.g., 1000 items)
        const keys = Object.keys(dataCache);
        if (keys.length > 1000) {
          const keysToKeep = keys.slice(-1000);
          const newCache = Object.fromEntries(keysToKeep.map(key => [key, dataCache[key]]));
          Object.assign(dataCache, newCache);

          // Clear old entries
          const clearRequest = store.clear();
          await new Promise((resolve, reject) => {
            clearRequest.onsuccess = resolve;
            clearRequest.onerror = reject;
          });
        }

        // Save new entries
        for (const [key, value] of Object.entries(dataCache)) {
          store.put({ imdbID: key, ...value });
        }

        // Update LocalStorage metadata
        metadata.keys = Object.keys(dataCache);
        metadata.lastUpdated = Date.now();
        try {
          localStorage.setItem('movieCacheMetadata', JSON.stringify(metadata));
          // Optionally save to LocalStorage as a fallback
          localStorage.setItem('movieDataCache', JSON.stringify(dataCache));
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            console.warn('LocalStorage full, clearing fallback cache');
            localStorage.removeItem('movieDataCache');
          }
        }
      } catch (error) {
        console.error('Error saving to IndexedDB:', error);
        // Fallback to LocalStorage
        try {
          localStorage.setItem('movieDataCache', JSON.stringify(dataCache));
          localStorage.setItem('movieCacheMetadata', JSON.stringify(metadata));
        } catch (e) {
          console.warn('Error saving to LocalStorage:', e);
        }
      }
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    async function fetchGenreMap() {
      if (genreMap) return genreMap;
      try {
        const response = await fetch(
          `https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}&language=en-US`
        );
        if (!response.ok) throw new Error(`TMDb genre list API error: ${response.status}`);
        const data = await response.json();
        genreMap = {};
        data.genres.forEach(genre => {
          genreMap[genre.id] = genre.name;
        });
        return genreMap;
      } catch (error) {
        console.error('Error fetching TMDb genre list:', error);
        return {};
      }
    }

    async function fetchMovieData(movie) {
      const cacheKey = movie.imdbID ? normalize(movie.imdbID) : normalize(movie.name);
      let { dataCache } = await loadCache();

      // Validate cached data
      if (dataCache[cacheKey] && dataCache[cacheKey].genre !== 'Unknown' && Array.isArray(dataCache[cacheKey].actors)) {
        console.log(`Cache hit for ${movie.name}:`, dataCache[cacheKey]);
        return dataCache[cacheKey];
      }

      const genreMap = await fetchGenreMap();
      console.log(`Fetching fresh TMDb data for ${movie.name}`);
      const maxRetries = 3;
      let attempt = 0;

      if (movie.imdbID) {
        while (attempt < maxRetries) {
          try {
            console.log(`Fetching TMDb data for IMDb ID: ${movie.imdbID}, attempt ${attempt + 1}`);
            const tmdbResponse = await fetch(
              `https://api.themoviedb.org/3/find/${movie.imdbID}?api_key=${TMDB_API_KEY}&language=en-US&external_source=imdb_id`
            );
            if (tmdbResponse.status === 429) {
              attempt++;
              const delay = Math.pow(2, attempt) * 1000;
              console.log(`Rate limit hit, retrying after ${delay}ms`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
            if (!tmdbResponse.ok) throw new Error(`TMDb API error: ${tmdbResponse.status}`);
            const tmdbData = await tmdbResponse.json();
            if (tmdbData.movie_results?.length > 0) {
              const tmdbMovieId = tmdbData.movie_results[0].id;
              console.log(`Found TMDb movie ID: ${tmdbMovieId}`);
              const movieResponse = await fetch(
                `https://api.themoviedb.org/3/movie/${tmdbMovieId}?api_key=${TMDB_API_KEY}&language=en-US`
              );
              if (!movieResponse.ok) throw new Error(`TMDb movie details API error: ${movieResponse.status}`);
              const movieData = await movieResponse.json();
              
              const creditsResponse = await fetch(
                `https://api.themoviedb.org/3/movie/${tmdbMovieId}/credits?api_key=${TMDB_API_KEY}`
              );
              if (!creditsResponse.ok) throw new Error(`TMDb credits API error: ${creditsResponse.status}`);
              const creditsData = await creditsResponse.json();
              
              const movieInfo = {
                rating: movieData.vote_average ? movieData.vote_average.toFixed(1) : movie.rating || 'N/A',
                plot: movieData.overview || movie.plot || 'Plot not available',
                director: creditsData.crew?.find(crew => crew.job === 'Director')?.name || movie.director || 'N/A',
                actors: creditsData.cast?.slice(0, 5).map(actor => actor.name) || movie.actors || [],
                genre: movieData.genre_ids?.length > 0
                  ? movieData.genre_ids.map(id => genreMap[id] || 'Unknown').filter(Boolean).join(', ')
                  : movieData.genres?.length > 0
                    ? movieData.genres.map(genre => genre.name).join(', ')
                    : movie.genre || 'Unknown',
                release_year: movieData.release_date ? movieData.release_date.split('-')[0] : movie.release_year || 'N/A'
              };
              dataCache[cacheKey] = movieInfo;
              await saveCache(dataCache, { lastUpdated: Date.now(), keys: Object.keys(dataCache) });
              console.log(`Fetched TMDb data for ${movie.name}:`, movieInfo);
              return movieInfo;
            }
          } catch (error) {
            console.error(`TMDb Error for ${movie.name} (IMDb ID attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt === maxRetries) break;
          }
        }
      }

      try {
        console.log(`Falling back to TMDb title search for: ${movie.name}`);
        const searchQuery = movie.name.replace(/[^\w\s]/g, ' ').trim();
        const searchResponse = await fetch(
          `https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(searchQuery)}&language=en-US`
        );
        if (!searchResponse.ok) throw new Error(`TMDb search API error: ${searchResponse.status}`);
        const searchData = await searchResponse.json();
        
        if (searchData.results?.length > 0) {
          const bestMatch = searchData.results[0];
          console.log(`TMDb search found: ${bestMatch.title} (${bestMatch.id})`);
          
          const movieResponse = await fetch(
            `https://api.themoviedb.org/3/movie/${bestMatch.id}?api_key=${TMDB_API_KEY}&language=en-US`
          );
          if (!movieResponse.ok) throw new Error(`TMDb movie details API error: ${movieResponse.status}`);
          const fullMovieData = await movieResponse.json();
          
          const creditsResponse = await fetch(
            `https://api.themoviedb.org/3/movie/${bestMatch.id}/credits?api_key=${TMDB_API_KEY}`
          );
          if (!creditsResponse.ok) throw new Error(`TMDb credits API error: ${creditsResponse.status}`);
          const creditsData = await creditsResponse.json();
          
          const movieInfo = {
            rating: fullMovieData.vote_average ? fullMovieData.vote_average.toFixed(1) : movie.rating || 'N/A',
            plot: fullMovieData.overview || movie.plot || 'Plot not available',
            director: creditsData.crew?.find(crew => crew.job === 'Director')?.name || movie.director || 'N/A',
            actors: creditsData.cast?.slice(0, 5).map(actor => actor.name) || movie.actors || [],
            genre: fullMovieData.genre_ids?.length > 0
              ? fullMovieData.genre_ids.map(id => genreMap[id] || 'Unknown').filter(Boolean).join(', ')
              : fullMovieData.genres?.length > 0
                ? fullMovieData.genres.map(genre => genre.name).join(', ')
                : movie.genre || 'Unknown',
            release_year: fullMovieData.release_date ? fullMovieData.release_date.split('-')[0] : movie.release_year || 'N/A'
          };
          dataCache[cacheKey] = movieInfo;
          await saveCache(dataCache, { lastUpdated: Date.now(), keys: Object.keys(dataCache) });
          console.log(`Fetched TMDb search data for ${movie.name}:`, movieInfo);
          return movieInfo;
        }
      } catch (error) {
        console.error(`TMDb search error for ${movie.name}:`, error);
      }

      const movieData = {
        rating: movie.rating || 'N/A',
        plot: movie.plot || 'Plot not available',
        director: movie.director || 'N/A',
        actors: movie.actors || [],
        genre: movie.genre || 'Unknown',
        release_year: movie.release_year || 'N/A'
      };
      dataCache[cacheKey] = movieData;
      await saveCache(dataCache, { lastUpdated: Date.now(), keys: Object.keys(dataCache) });
      console.log(`Using fallback data for ${movie.name}:`, movieData);
      return movieData;
    }

    function createSelectionButtons(container, items, itemKey, idKey, labelKey, clickHandler, activeId) {
      container.innerHTML = "";
      container.style.display = items.length > 0 ? "block" : "none";
      items.forEach((item, idx) => {
        const button = document.createElement("div");
        button.className = 'button';
        button.innerHTML = `
          <div class="button-outer">
            <div class="button-inner">
              <span>${item[labelKey] || `Source ${idx + 1}`}</span>
            </div>
          </div>
        `;
        button.dataset[idKey] = item[idKey] || item[labelKey] || idx;
        button.onclick = () => {
          clickHandler(item);
          Array.from(container.getElementsByClassName("button")).forEach((btn) =>
            btn.classList.remove("active")
          );
          button.classList.add("active");
        };
        if (button.dataset[idKey] === activeId) {
          button.classList.add("active");
        }
        container.appendChild(button);
      });
    }

    async function loadVideo(video) {
      if (!video) {
        document.getElementById("video-title").innerText = "Video not found";
        errorMessage.textContent = "No video data provided. Please select a valid movie.";
        errorMessage.style.display = "block";
        iframeContainer.style.display = "none";
        sourceSelection.style.display = "none";
        trailerContainer.style.display = "none";
        trailerTitle.classList.remove("visible");
        movieInfo.style.display = "none";
        imdbRatingCircle.style.display = "none";
        return;
      }

      document.getElementById("video-title").innerText = video.name || "Untitled";
      document.title = video.name || "Video";
      errorMessage.style.display = "none";

      let movieData;
      try {
        movieData = await fetchMovieData(video);
      } catch (error) {
        console.error(`Error fetching movie data for ${video.name}:`, error);
        movieData = {
          rating: video.rating || 'N/A',
          plot: video.plot || 'Plot not available',
          director: video.director || 'N/A',
          actors: video.actors || [],
          genre: video.genre || 'Unknown',
          release_year: video.release_year || 'N/A'
        };
        errorMessage.textContent = "Failed to fetch movie details from TMDb. Displaying available data.";
        errorMessage.style.display = "block";
      }

      console.log(`movieData for ${video.name}:`, movieData); // Debug log

      const rating = parseFloat(movieData.rating);
      if (!isNaN(rating) && rating > 0) {
        const percentage = (rating / 10) * 100;
        ratingCircle.style.setProperty('--percentage', `${percentage}%`);
        ratingValue.textContent = movieData.rating;
        imdbRatingCircle.style.display = "flex";
      } else {
        imdbRatingCircle.style.display = "none";
      }

      moviePlot.textContent = movieData.plot || 'Plot not available';

      // Director rendering
      director.innerHTML = '';
      if (movieData.director && movieData.director !== 'N/A') {
        const container = document.createElement('div');
        container.className = 'container';
        const button = document.createElement('div');
        button.className = 'button';
        button.innerHTML = `
          <div class="button-outer">
            <div class="button-inner">
              <span><a href="search.html#director=${encodeURIComponent(movieData.director)}" class="info-link" target="_self">${movieData.director}</a></span>
            </div>
          </div>
        `;
        container.appendChild(button);
        director.appendChild(container);
      } else {
        director.textContent = 'N/A';
      }

      // Main Cast rendering
      mainCast.innerHTML = '';
      if (Array.isArray(movieData.actors) && movieData.actors.length > 0) {
        movieData.actors.forEach((actor) => {
          const container = document.createElement('div');
          container.className = 'container';
          const button = document.createElement('div');
          button.className = 'button';
          button.innerHTML = `
            <div class="button-outer">
              <div class="button-inner">
                <span><a href="search.html#actor=${encodeURIComponent(actor)}" class="info-link" target="_self">${actor}</a></span>
              </div>
            </div>
          `;
          container.appendChild(button);
          mainCast.appendChild(container);
        });
      } else {
        mainCast.textContent = 'N/A';
      }

      // Genres rendering
      imdbCategories.innerHTML = '';
      if (movieData.genre && movieData.genre !== 'Unknown') {
        const genres = movieData.genre.split(', ');
        genres.forEach((genre) => {
          const container = document.createElement('div');
          container.className = 'container';
          const button = document.createElement('div');
          button.className = 'button';
          button.innerHTML = `
            <div class="button-outer">
            <div class="button-inner">
              <span><a href="search.html#genre=${encodeURIComponent(genre)}" class="info-link" target="_self">${genre}</a></span>
            </div>
          </div>
        `;
          container.appendChild(button);
          imdbCategories.appendChild(container);
        });
      } else {
        imdbCategories.textContent = 'Unknown';
      }

      // Release Year rendering
      releaseYear.innerHTML = '';
      if (movieData.release_year && movieData.release_year !== 'N/A') {
        const container = document.createElement('div');
        container.className = 'container';
        const button = document.createElement('div');
        button.className = 'button';
        button.innerHTML = `
          <div class="button-outer">
            <div class="button-inner">
              <span><a href="search.html#year=${encodeURIComponent(movieData.release_year)}" class="info-link" target="_self">${movieData.release_year}</a></span>
            </div>
          </div>
        `;
        container.appendChild(button);
        releaseYear.appendChild(container);
      } else {
        releaseYear.textContent = 'N/A';
      }

      movieInfo.style.display = "block";

      const sources = Array.isArray(video.sources) ? video.sources : [];
      createSelectionButtons(
        sourceSelection,
        sources,
        "source",
        "sourceId",
        "label",
        (source) => {
          iframeContainer.innerHTML = source.embed_code || "";
          iframeContainer.style.display = "block";
        },
        sources[0]?.label
      );

      if (sources.length > 0) {
        iframeContainer.innerHTML = sources[0].embed_code || "";
        iframeContainer.style.display = "block";
      } else {
        iframeContainer.style.display = "none";
        errorMessage.textContent = "No video sources available for this movie.";
        errorMessage.style.display = "block";
      }

      if (video.trailer) {
        trailerIframeContainer.innerHTML = video.trailer;
        trailerContainer.style.display = "block";
        setTimeout(() => {
          trailerTitle.classList.add("visible");
        }, 10);
      } else {
        trailerIframeContainer.innerHTML = '<p>No trailer available</p>';
        trailerContainer.style.display = "none";
        trailerTitle.classList.remove("visible");
      }
    }

    async function loadCategories() {
      const maxRetries = 3;
      let attempt = 0;

      while (attempt < maxRetries) {
        try {
          const data = await fetch("movies.json").then((res) => {
            if (!res.ok) throw new Error(`Failed to fetch movies.json: ${res.status}`);
            return res.json();
          });
          const categories = [...new Set(data.map((row) => row.category).filter(Boolean))];
          categoryList.innerHTML = "";
          if (categories.length === 0) {
            categoryList.innerHTML = "<p>No categories available</p>";
            errorMessage.textContent = "No categories found in movie data.";
            errorMessage.style.display = "block";
          } else {
            categories.forEach((category) => {
              const categoryItem = document.createElement("a");
              categoryItem.textContent = category;
              categoryItem.href = `category.html#${category.replace(/\s+/g, '')}`;
              categoryItem.setAttribute("role", "option");
              categoryList.appendChild(categoryItem);
            });
          }
          return;
        } catch (error) {
          console.error(`Error loading categories (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt === maxRetries) {
            console.error("Max retries reached for loading categories");
            errorMessage.textContent = "Failed to load categories. Please try again later.";
            errorMessage.style.display = "block";
          }
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    async function loadMovie() {
      const movieNameParam = decodeURIComponent(window.location.hash.substring(1));
      if (!movieNameParam) {
        document.getElementById("video-title").innerText = "Video name missing in URL";
        errorMessage.textContent = "Please provide a valid movie name in the URL (e.g., movie.html#MovieName).";
        errorMessage.style.display = "block";
        return;
      }

      const maxRetries = 3;
      let attempt = 0;

      while (attempt < maxRetries) {
        try {
          const moviesData = await fetch("movies.json").then((res) => {
            if (!res.ok) throw new Error(`Failed to fetch movies.json: ${res.status}`);
            return res.json();
          });
          const movie = moviesData.find((v) => normalize(v.name.replace(/\s+/g, '')) === normalize(movieNameParam));

          if (movie) {
            console.log("Movie found:", movie);
            await loadVideo(movie);
            return;
          } else {
            document.getElementById("video-title").innerText = "Video not found";
            errorMessage.textContent = `Movie "${movieNameParam}" not found in the database.`;
            errorMessage.style.display = "block";
            return;
          }
        } catch (error) {
          console.error(`Error loading movie data (attempt ${attempt + 1}):`, error);
          attempt++;
          if (attempt === maxRetries) {
            console.error("Max retries reached for loading movie data");
            document.getElementById("video-title").innerText = "Error loading video";
            errorMessage.textContent = "Failed to load movie data. Please check your network or JSON file.";
            errorMessage.style.display = "block";
          }
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    async function handleSearch() {
      const query = searchInput.value.toLowerCase();
      if (!query) {
        searchResultsContainer.style.display = "none";
        searchResultsContainer.innerHTML = "";
        return;
      }

      try {
        const data = await fetch("movies.json").then((res) => {
          if (!res.ok) throw new Error(`Failed to fetch movies.json: ${res.status}`);
          return res.json();
        }).catch(() => []);
        const filteredVideos = data.filter(
          (video) =>
            normalize(video.name).includes(normalize(query)) &&
            video.thumbnail &&
            video.thumbnail.trim() !== ""
        );

        searchResultsContainer.style.display = "block";
        searchResultsContainer.innerHTML = "";

        const searchResultsWithRatings = await Promise.all(
          filteredVideos.slice(0, 5).map(async (video) => {
            const movieData = await fetchMovieData(video);
            return { ...video, rating: movieData.rating };
          })
        );

        searchResultsWithRatings.forEach((video) => {
          const suggestionItem = document.createElement("div");
          suggestionItem.classList.add("search-suggestion");
          suggestionItem.setAttribute("role", "option");
          suggestionItem.innerHTML = `
            <img src="${video.thumbnail}" alt="${video.name}" />
            <span>${video.name} (TMDb: ${video.rating})</span>
          `;
          suggestionItem.addEventListener("click", () => {
            window.location.href = `movie.html#${video.name.replace(/\s+/g, '')}`;
          });
          searchResultsContainer.appendChild(suggestionItem);
        });

        if (filteredVideos.length === 0) {
          searchResultsContainer.innerHTML = `<div class="no-results">No results found for "${query}"</div>`;
        }
      } catch (error) {
        console.error("Error during search:", error);
        searchResultsContainer.innerHTML = `<div class="no-results">Error during search</div>`;
        errorMessage.textContent = "Failed to perform search. Please try again.";
        errorMessage.style.display = "block";
      }
    }

    function handleEnter(event) {
      if (event.key === "Enter") {
        const query = searchInput.value.trim();
        if (query) {
          window.location.href = `search.html#keyword=${encodeURIComponent(query)}`;
        }
      }
    }

    async function initialize() {
      await loadCategories();
      await loadMovie();
    }

    searchInput.addEventListener("input", debounce(handleSearch, 300));
    searchInput.addEventListener("keydown", handleEnter);

    document.addEventListener("DOMContentLoaded", function () {
      const dropdown = document.querySelector(".dropdown");
      const dropdownContent = document.querySelector(".dropdown-content");
      const navbar = document.querySelector(".navbar");

      let lastScrollTop = 0;
      window.addEventListener("scroll", function () {
        let scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        if (scrollTop > lastScrollTop) {
          navbar.classList.add("fixed");
        } else {
          navbar.classList.remove("fixed");
        }
        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
      });

      dropdown.addEventListener("click", function (event) {
        event.stopPropagation();
        dropdownContent.style.display =
          dropdownContent.style.display === "block" ? "none" : "block";
        dropdown.setAttribute("aria-expanded", dropdownContent.style.display === "block");
      });

      document.addEventListener("click", function (event) {
        if (!dropdown.contains(event.target)) {
          dropdownContent.style.display = "none";
          dropdown.setAttribute("aria-expanded", "false");
        }
      });

      initialize();
    });
  </script>
</body>
</html>
